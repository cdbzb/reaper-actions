--[[
   * ReaScript Name: mpl Warping Tool
   * Lua script for Cockos REAPER
   * Author: Michael Pilyavskiy (mpl)
   * Author URI: http://forum.cockos.com/member.php?u=70694
   * Licence: GPL v3
   * Version: 
  ]]

  local vrs = 0.281
  local changelog =                           
[===[ Changelog:
21.01.2016  0.281
            + Syllables alighn engine
            + Play cursor
20.01.2016  0.272
            # Check for negative stretch markers
            - Removed Phrases internal stretch
20.01.2016  0.27
            Open for public testing
19.01.2016  0.265
            + Phrases alighn engine
            + Prepare takes for editing
            + GUI improvements
            + /Reaper/Scripts/mpl_WarpingTool.ini parser
06.01.2016  0.25 Testing New Algorithms
27.10.2015  0.23 Early alpha            
01.09.2015  0.01 Alignment / Warping / Tempomatching tool idea
 ]===]

----------------------------------------------------------------------- 
  function msg(str)
    if type(str) == 'boolean' then if str then str = 'true' else str = 'false' end end
    if type(str) == 'userdata' then str = str.get_alloc() end
    if str ~= nil then 
      reaper.ShowConsoleMsg(tostring(str)..'\n') 
      if str ==  "" then reaper.ShowConsoleMsg("") end
     else
      reaper.ShowConsoleMsg('nil')
    end    
  end
  
----------------------------------------------------------------------- 
  function fdebug(str) if debug_mode == 1 then msg(os.date()..' '..str) end end  
  
----------------------------------------------------------------------- 
  function MAIN_exit()
    reaper.atexit()
    gfx.quit()
  end  

-----------------------------------------------------------------------   
  function DEFINE_dynamic_variables()
    char = gfx.getchar()
    play_pos = reaper.GetPlayPosition(0)
  end

-----------------------------------------------------------------------
  function F_limit(val,min,max,retnil)
    if val == nil or min == nil or max == nil then return 0 end
    local val_out = val 
    if val == nil then val = 0 end
    if val < min then  val_out = min 
      if retnil then return nil end
    end
    if val > max then val_out = max 
      if retnil then return nil end
    end
    return val_out
  end 
    
-----------------------------------------------------------------------    
  function F_Get_SSV(s)
    local t = {}
    for i in s:gmatch("[%d%.]+") do 
      t[#t+1] = tonumber(i) / 255
    end
    gfx.r, gfx.g, gfx.b = t[1], t[2], t[3]
  end
  
----------------------------------------------------------------------- 
  function ENGINE_get_takes() 
    local take_guid
    local take_name
    local takes_t = {}
    local count_items = reaper.CountSelectedMediaItems()
    if count_items ~= nil then 
      for i =1, count_items do 
        local item = reaper.GetSelectedMediaItem(0, i-1)
        if item ~= nil then
          local item_len  = reaper.GetMediaItemInfo_Value( item, 'D_LENGTH')
          local item_pos  = reaper.GetMediaItemInfo_Value( item, 'D_POSITION')
          local take = reaper.GetActiveTake(item)
          if not reaper.TakeIsMIDI(take) then    
            take_guid = reaper.BR_GetMediaItemTakeGUID(take)
            _, take_name = reaper.GetSetMediaItemTakeInfo_String(take, 'P_NAME', '', false)      
            local t_offs = reaper.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS')
            table.insert(takes_t, 
              {['guid']=take_guid,
               ['name']=take_name,
               ['len']=item_len,
               ['pos']=item_pos,
               ['offset']=t_offs})
          end
        end    
      end        
    end   
    return takes_t 
  end  

-----------------------------------------------------------------------     
  function ENGINE_prepare_takes() local item, take
    local count_items = reaper.CountSelectedMediaItems()
    if count_items == nil or count_items < 1 then return end
    
    -- macro alighn
      if data.current_window == 1 
      or data.current_window == 2 then
        reaper.Main_OnCommand(41844,0) -- clear stretch markers
        reaper.Main_OnCommand(40652,0) -- set item rate to 1
        
        -- check for unglued reference item/take
          local ref_item = reaper.GetSelectedMediaItem(0, 0)
          if ref_item == nil then return end
          local ref_track = reaper.GetMediaItemTrack(ref_item)
          local ref_pos = reaper.GetMediaItemInfo_Value(ref_item, 'D_POSITION')
          local ref_len = reaper.GetMediaItemInfo_Value(ref_item, 'D_LENGTH')
          for i = 2, count_items do
            item = reaper.GetSelectedMediaItem(0, i-1)
            track = reaper.GetMediaItemTrack(item)
            if track == ref_track then
              reaper.MB('Reference item/take should be glued','Warping tool', 0)
              return
            end
          end
          
        -- check for edges
          for i = 2, count_items do
            item = reaper.GetSelectedMediaItem(0, i-1)
            local pos = reaper.GetMediaItemInfo_Value(item, 'D_POSITION')
            local len = reaper.GetMediaItemInfo_Value(item, 'D_LENGTH')
            if pos < ref_pos then 
              reaper.SetMediaItemInfo_Value(item, 'D_POSITION', ref_pos) 
              local take = reaper.GetActiveTake(item)   
              local take_offs = reaper.GetMediaItemTakeInfo_Value(take, 'D_STARTOFFS')
              reaper.SetMediaItemTakeInfo_Value(take, 'D_STARTOFFS', take_offs + ref_pos - pos)
            end
            
            if ref_pos + ref_len < pos+len then
              reaper.SetMediaItemInfo_Value(item, 'D_LENGTH', len - (pos+len - ref_pos  - ref_len)) 
            end
            
          end
      end
    
    reaper.UpdateArrange()
    return 1 -- successful
  end
  
-----------------------------------------------------------------------   
  function ENGINE_get_take_data(take_id, scaling)
    local st_win_cnt,end_win_cnt
    
    local fft_size = 1024 
    local HP = 3 
    local LP = fft_size -- end spectrum
    
    
    fdebug('HP freq'..HP*22050/fft_size)
    fdebug('LP freq'..LP*22050/fft_size)
    
    local fft_sum_com
    local fft_sum = 0    
    local aa = {}
    local fft_sum_t = {}
    local rms_t = {}
    
    if takes_t ~= nil and takes_t[take_id] ~= nil then
      local take = reaper.SNM_GetMediaItemTakeByGUID(0, takes_t[take_id].guid)
      if take ~= nil then
        local item = reaper.GetMediaItemTake_Item(take)
        local item_len = reaper.GetMediaItemInfo_Value(item, 'D_LENGTH')
        aa.accessor = reaper.CreateTakeAudioAccessor(take)
        aa.src = reaper.GetMediaItemTake_Source(take)
        aa.numch = reaper.GetMediaSourceNumChannels(aa.src)
        aa.rate = reaper.GetMediaSourceSampleRate(aa.src) 
        
          aa.window_sec = fft_size/aa.rate -- ms
          data.global_window_sec = aa.window_sec
          
          -- get fft_size samples buffer
            for read_pos = 0, item_len, aa.window_sec do 
            
              aa.buffer = reaper.new_array(fft_size*2)
              aa.buffer_com = reaper.new_array(fft_size*2)
               
              reaper.GetAudioAccessorSamples(
                    aa.accessor , --AudioAccessor
                    aa.rate, -- samplerate
                    2,--aa.numch, -- numchannels
                    read_pos, -- starttime_sec
                    fft_size, -- numsamplesperchannel
                    aa.buffer) --samplebuffer
                    
              -- merge buffers dy duplicating sum/2
                for i = 1, fft_size*2 - 1, 2 do
                  aa.buffer_com[i] = (aa.buffer[i] + aa.buffer[i+1])/2
                  aa.buffer_com[i+1] = 0
                end
                
                
              -- Get FFT sum of bins in defined range
                aa.buffer_com.fft(fft_size, true, 1)
                aa.buffer_com_t = aa.buffer_com.table(1,fft_size, true)
                fft_sum_com = 0
                for i = HP, LP do
                  fft_sum_com = fft_sum_com + math.abs(aa.buffer_com_t[i])
                end    
                table.insert(fft_sum_t, fft_sum_com /(LP-HP))
                                
                                    
              --[[ rms table
                aa.buffer_t = aa.buffer.table(1,fft_size*2, true)
                rms_sum = 0
                for i = 1, fft_size/2 do rms_sum = rms_sum + math.abs(aa.buffer_t[i])--^0.8 end   
                table.insert(rms_t, rms_sum)]]
                
                aa.buffer.clear()
                aa.buffer_com.clear()              
            end
            
        reaper.DestroyAudioAccessor(aa.accessor)
       else return
      end
     else return
    end
    
    --out_t = rms_t
    local out_t = fft_sum_t
    
    -- normalize table
      local max_com = 0
      for i =1, #out_t do max_com = math.max(max_com, out_t[i]) end
      local com_mult = 1/max_com      
      for i =1, #out_t do out_t[i]= out_t[i]*com_mult  end
    
    -- return scaled table
      for i =1, #out_t do out_t[i]= out_t[i]^scaling  end
      
    --[[ normalize table
      local max_com = 0
      for i =1, #out_t do max_com = math.max(max_com, out_t[i]) end
      com_mult = 1/max_com      
      for i =1, #out_t do out_t[i]= out_t[i]*com_mult  end    ]]  
    
    -- fill null to reference item
      if take_id > 1 then
        st_win_cnt = math.floor ((takes_t[take_id].pos - takes_t[1].pos) 
        / data.global_window_sec)
        end_win_cnt = math.floor
          ((takes_t[1].pos + takes_t[1].len - takes_t[take_id].pos - takes_t[take_id].len) 
          / data.global_window_sec)
        -- fill from start
          if takes_t[take_id].pos > takes_t[1].pos then            
            for i = 1, st_win_cnt do table.insert(out_t, 1, 0) end
          end
        -- fill end
          if takes_t[take_id].pos + takes_t[take_id].len < 
              takes_t[1].pos + takes_t[1].len then
            for i = 1, end_win_cnt do out_t[#out_t+1] = 0 end
          end
      end
    
      if out_t ~= nil and #out_t > 1 then
        local out_array = reaper.new_array(out_t, #out_t)
        return out_array
      end
  end 

-----------------------------------------------------------------------   
  function ENGINE_get_take_data_points1(inputarray, window_sec) -- macro mode
    local exists_in_st_area,gate_id_st,last_gate_id
    
    if inputarray == nil then return end
    local arr_size = inputarray.get_alloc()
    if arr_size <=1 then return end
    local points = reaper.new_array(arr_size)
    --  clear arr val
      for i = 1, arr_size do
        points[i] = 0
      end  
    
    local threshold_scaled = (10^(data.threshold1/20))^data.scaling_pow1
    local min_phrase_time_wind = math.floor(data.min_phrase_time1 / window_sec)
    
    local gate = false
    -- gate stuff
      for i = 1, arr_size do
        -- gate open
          if inputarray[i] > threshold_scaled and not gate then
            gate = true
            gate_id_st = i
            points[i] = 1
            last_gate_id = i
          end
        
        if inputarray[i] < threshold_scaled and gate and i - last_gate_id > min_phrase_time_wind then 
          gate = false
          points[i] = 1
          if i - gate_id_st < min_phrase_time_wind then
            points[i] = 0
            points[gate_id_st] = 0
          end
          gate_id_st = nil
        end
      end
        
      -------------------------
      
    -- check for ending
      local block_ids = {}
      for i = 1, arr_size do
        if points[i] == 1 then
          block_ids[#block_ids+1] = i
        end
      end    
      if #block_ids % 2 == 1 then points[arr_size-1] = 1 end
      
      if #block_ids < 2 then return end
    -- check if last block less than min length
      local last_block = (arr_size-1) - block_ids[#block_ids-1]
      if last_block < min_phrase_time_wind then 
        points[arr_size-1] = 0
        points[block_ids[#block_ids-1]] = 0
      end
      
    -- check for relative empty blocks
      for i = 1, #block_ids - 1, 2 do
        -- get rms of blocl
        local val_sum = 0
        for k = block_ids[i], block_ids[i+1] do
          val_sum = val_sum + inputarray[k]
        end
        val_sum = val_sum / (block_ids[i+1] - block_ids[i])
        if val_sum < threshold_scaled then
          points[block_ids[i]] = 0
          points[block_ids[i+1]] = 0
        end        
      end
      
    return points
  end
        
-----------------------------------------------------------------------  
  function ENGINE_get_take_data_points2(inputarray, window_sec) -- micro mode
    local exists_in_st_area,gate_id_st,last_gate_id
    
    if inputarray == nil then return end
    local arr_size = inputarray.get_alloc()    
    if arr_size <=1 then return end
    
    local points = reaper.new_array(arr_size)
    
    --  clear arr val
      for i = 1, arr_size do points[i] = 0 end  
      
    local threshold_scaled = (10^(data.threshold2/20))^data.scaling_pow2
    local threshold_rise_scaled = (10^(-data.threshold_rise2/20))^data.scaling_pow2
    local risearea_wind = math.floor(data.rise_area2 / window_sec)
    local filter_area_wind = math.floor(data.filter_area2 / window_sec)
    
    -- gate stuff
      for i = 2, arr_size do
        -- gate open
          if inputarray[i] > threshold_scaled and 
             inputarray[i-1] < threshold_scaled then
            points[i] = 1
          end
        -- gate close
        if inputarray[i] < threshold_scaled and 
            inputarray[i-1] > threshold_scaled then 
          points[i] = 1
        end
      end
      
    -- check for rise
      for i = 1, arr_size - risearea_wind do 
        -- check for start points
        if i <= risearea_wind and inputarray[i] > threshold_scaled then 
          points[1] = 1 
         else
         
          --further points  
          if inputarray[i] > threshold_scaled then
            -- check area
            max_val = 0
            for k = i, i + risearea_wind do
              max_val = math.max(max_val, inputarray[k])
            end
            if max_val - inputarray[i] > threshold_rise_scaled then
              points[i] = 1 
            end
          end  
               
        end -- cond start area
      end
    
    local point_k_val,point_i_val,max_val
    -- filter points
      for i = 1, arr_size - filter_area_wind - 1 do 
        if points[i] == 1 then
          point_i_val = inputarray[i]
          max_val = 0
          for k = i + 1, i + 1 + filter_area_wind do
            if points[k] == 1 then 
              point_k_val = inputarray[k]
              max_val = math.max(max_val,point_k_val)
            end
          end
          --if point_i_val < max_val then points[i] = 0 end
          if max_val ~= 0 then points[i] = 0 end
        end
      end
      
    points[1] = 1
    points[arr_size] = 1
    return points
  end
 
-----------------------------------------------------------------------    
  function F_find_arrays_com_diff(ref_array, ref_array_offset, dub_array)
    local dub_array_size = dub_array.get_alloc()
    local ref_array_size = ref_array.get_alloc()
    local endpoint
    local com_difference = 0
    if ref_array_offset + dub_array_size > ref_array_size then endpoint = ref_array_size - ref_array_offset
      else endpoint = dub_array_size end
      
    for i = 1, endpoint do
      com_difference = com_difference + math.abs(ref_array[i + ref_array_offset - 1 ]-dub_array[i])
    end
    return com_difference
  end

-----------------------------------------------------------------------   
  function F_find_min_value(reaperarray)
    reaperarray_size = reaperarray.get_alloc()
    min_dif0 = math.huge
    local min_dif, min_dif_id
    for k = 1, reaperarray_size do
      min_dif = math.min(reaperarray[k], min_dif0)
      if min_dif ~= min_dif0 then 
        min_dif0 = min_dif 
        min_dif_id = k 
      end
    end  
    return min_dif_id
  end
  
-----------------------------------------------------------------------  
  function ENGINE_compare_data1(ref_arr, dub_arr, dub_points_arr, window_sec)
    local st_search, end_search
    
    if ref_arr == nil then return end
    if dub_arr == nil then return end
    if dub_points_arr == nil then return end
    
    local dub_arr_size = dub_arr.get_alloc()
    
    local sm_table = {}
    local sm_table2 = {}
    
    local max_search_area_wind = 
      math.floor(data.max_search_area1 / window_sec)
      
    -- get blocks
       local block_ids = {}
      for i = 1, dub_arr_size do
        if dub_points_arr[i] == 1 then
          block_ids[#block_ids+1] = i
        end
      end    
      -- erase unfinished block
      if #block_ids % 2 == 1 then block_ids[#block_ids] = nil end
    
    -- loop blocks
    
      for i = 1, #block_ids - 1 , 2 do
        -- create fixed block
          local fantom_arr_size = block_ids[i+1] - block_ids[i] + 1
          local fantom_arr = reaper.new_array(fantom_arr_size)
          fantom_arr.copy(dub_arr,--src, 
                          block_ids[i],--srcoffs, 
                          fantom_arr_size,--size, 
                          1)--destoffs])
          
          -- PHRASES ALG 1 -- 
          
        -- loop whole segment pos
          if i == 1 then st_search = 1 else 
            st_search = block_ids[i-1] + 1 end
            
          if block_ids[i] - st_search > max_search_area_wind then 
            st_search = block_ids[i] - max_search_area_wind end
                        
          if i ~= #block_ids - 1 then end_search = block_ids[i+2] - fantom_arr_size - 1 else 
            end_search = dub_arr_size - fantom_arr_size - 1 end
            
          if end_search - block_ids[i] > max_search_area_wind then
            end_search = block_ids[i] + max_search_area_wind - 1 end
            
            --[[msg('------------------------'..i)
            msg('st_search'..st_search)
            msg('end_search'..end_search)
            msg(ref_arr)
            msg('max_search_area_wind'..max_search_area_wind)]]
            
        -- find best fit
          local diff_t = {}
          for k = st_search, end_search do
            local diff_com = 0
            for m = 1, fantom_arr_size do
              diff_com = diff_com + math.abs(fantom_arr[m]-ref_arr[k+m-1])
            end
            diff_t[k-st_search+1] = diff_com
          end
          
        -- check diff t
          local min_dif0 = math.huge
          local min_dif, min_dif_id,min_dif_id2
          for k = 1, #diff_t do
            min_dif = math.min(diff_t[k], min_dif0)
            if min_dif ~= min_dif0 then 
              min_dif0 = min_dif 
              min_dif_id = k 
            end
          end          
          if min_dif_id ~= nil then 
            min_dif_id = min_dif_id + st_search - 1  
              
            -- extract into str m table
              sm_table[#sm_table+1] =  
                  {min_dif_id*  window_sec,
                    block_ids[i]* window_sec}
              sm_table[#sm_table+1] =
                  {(min_dif_id+ fantom_arr_size) *  window_sec,
                    block_ids[i+1]* window_sec}
              --[[sm_table[#sm_table+1] = {min_dif_id,block_ids[i]} -- test sm
              sm_table[#sm_table+1] = {min_dif_id + fantom_arr_size,
                                        block_ids[i+1]}]]
           else
            min_dif_id = block_ids[i]
          end -- if found diff id 
      end  
    
    return sm_table, sm_table2
  end    
  
-----------------------------------------------------------------------   
  --[[f unction ENGINE_compare_data(arr_1, arr_2, arr_3)
 
      
      for block = 1, #block_ids - 2 do
        --block = 2
        diff_t = {}
        block_1st = block_ids[block]
        block_2point = block_ids[block+1]  
        block_3end = block_ids[block+2]    
        -- create fixed block
          fantom_block_t = {}      
          for i = block_1st, block_3end do fantom_block_t[i] = val1_t[i] end      
        
        -- loop possible positions 
          for point = block_1st, block_3end - 1 do
            
            -- rebuild samples
            for i = block_1st, block_3end do
              coeff = (point - block_1st) / (block_2point - block_1st)
              id_before_point = math.floor((i - block_1st) / coeff + block_1st)
              coeff2 = (i - point) / (block_3end - point)
              id_after_point = math.floor(block_2point + (block_3end - block_2point) * coeff2)
              if i < point then 
                val1_t[i] = fantom_block_t[id_before_point] 
               else
                val1_t[i] = fantom_block_t[id_after_point] 
              end
            end
            
            -- add to fits t
            diff_com = 0
            for i = block_1st, block_3end do
              diff_com = diff_com + math.abs(val0_t[i]-val1_t[i])
            end
            diff_t[#diff_t+1] = diff_com   
            
          end
          
        ---------------------------------
          
        -- check best fit
          min_dif0 = math.huge
          for i = 1, #diff_t do
            min_dif = math.min(diff_t [i], min_dif0)
            if min_dif ~= min_dif0 then min_dif0 = min_dif 
              min_dif_id = i 
            end
          end
          min_dif_id = min_dif_id + block_1st
          
        ---------------------------------
          
        -- apply fantom block with best fit
          point = min_dif_id - 1 
          for i = block_1st, block_3end do
            coeff = (point - block_1st) / (block_2point - block_1st)
            id_before_point = math.floor((i - block_1st) / coeff + block_1st)
            coeff2 = (i - point) / (block_3end - point)
            id_after_point = math.floor(block_2point + (block_3end - block_2point) * coeff2)
            if i < point then 
              val1_t[i] = fantom_block_t[id_before_point] 
             else
              val1_t[i] = fantom_block_t[id_after_point] 
            end
          end 
          
        ---------------------------------
          
        -- apply best fit to block id t
          val1_points_t[block_2point] = 0
          val1_points_t[min_dif_id] = 1          
          if math.abs(block_2point - min_dif_id) < min_area 
            and math.abs(block_2point - min_dif_id) > 1
            then
            --sm_table[#sm_table+1] = {block_2point, min_dif_id}
            sm_table[#sm_table+1] =  
              {min_dif_id*data.global_window_sec,
               block_2point*data.global_window_sec}
            block_ids[block+1] = min_dif_id  
          end
      end
      
    return sm_table
      
  end]]
  
-----------------------------------------------------------------------   
  function F_stretch_array(src_array, new_size)
    local src_array_size = src_array.get_alloc()
    
    local out_array = reaper.new_array(new_size)
    
    if      new_size == src_array_size then 
      out_array = src_array 
      return out_array
      
     elseif new_size < src_array_size then
      for i = 1, new_size do
        i_new = math.ceil(i * (src_array_size / new_size ))
        if i_new > src_array_size then i_new = src_array_size end 
        out_array[i] = src_array[i_new]
      end
      return out_array
      
     elseif new_size > src_array_size then
      for i = 1, new_size do
        i_new = math.ceil(i / (new_size / src_array_size))
        if i_new > src_array_size then i_new = src_array_size end
        out_array[i] = src_array[i_new]
      end
      return out_array     
    end
  end
    
-----------------------------------------------------------------------    
  function F_stretch_array2(src_array, src_mid_point, stretched_point)
    --[[msg('--------')
    msg(src_mid_point)
    msg(stretched_point)]]
    if src_array == nil or src_mid_point == nil or stretched_point == nil 
      then return end
      
    local src_array_size = src_array.get_alloc()
    local out_arr = reaper.new_array(src_array_size)
    
    local src_arr_pt1_size = src_mid_point - 1
    local src_arr_pt2_size = src_array_size-src_mid_point + 1
    
    local out_arr_pt1_size = stretched_point - 1
    local out_arr_pt2_size = src_array_size-stretched_point + 1
    
    local src_arr_pt1 = reaper.new_array(src_arr_pt1_size)
    local src_arr_pt2 = reaper.new_array(src_arr_pt2_size)
    
    src_arr_pt1.copy(src_array,--src, 
                            1,--srcoffs, 
                            src_arr_pt1_size,--size, 
                            1)--destoffs])  
    src_arr_pt2.copy(src_array,--src, 
                            src_mid_point,--srcoffs, 
                            src_arr_pt2_size,--size, 
                            1)--destoffs])
                            
    local out_arr_pt1 = F_stretch_array(src_arr_pt1, out_arr_pt1_size)
    local out_arr_pt2 = F_stretch_array(src_arr_pt2, out_arr_pt2_size)
    
    out_arr.copy(out_arr_pt1,--src, 
                 1,--srcoffs, 
                 out_arr_pt1_size,--size, 
                 1)--destoffs]) 
    out_arr.copy(out_arr_pt2,--src, 
                 1,--srcoffs, 
                 out_arr_pt2_size,--size, 
                 out_arr_pt1_size + 1)--destoffs]) 
                 
    return   out_arr               
  end
  
-----------------------------------------------------------------------      
  function ENGINE_compare_data2(ref_arr, dub_arr, points, window_sec)
    local st_search, end_search
    
    if ref_arr == nil then return end
    if dub_arr == nil then return end
    if points == nil then return end

    local sm_table = {}    
    local dub_arr_size = dub_arr.get_alloc()      
    search_area = math.floor(data.max_search_area2 / window_sec)
            
    -- get blocks
      block_ids = {}
      for i = 1, dub_arr_size do
        if points[i] == 1 then block_ids[#block_ids+1] = i end
      end    
      
    -- loop blocks
      for i = 1, #block_ids - 2 do
        -- create fixed block
          fantom_arr_size = block_ids[i+2] - block_ids[i] + 1
          
          local fantom_arr = reaper.new_array(fantom_arr_size)
          fantom_arr.copy(dub_arr,--src, 
                          block_ids[i],--srcoffs, 
                          fantom_arr_size,--size, 
                          1)--destoffs])
                          
        -- loop possible positions
          local min_block_len = 3
          search_pos_start = block_ids[i+1] - search_area
          if search_pos_start < block_ids[i] + min_block_len then
            search_pos_start = block_ids[i] + min_block_len end
          search_pos_end = block_ids[i+1] + search_area
          if search_pos_end > block_ids[i+2] - min_block_len then
            search_pos_end = block_ids[i+2] - min_block_len end    
          if (search_pos_end-search_pos_start+1) > min_block_len then
            
          
            diff = reaper.new_array(search_pos_end-search_pos_start+1)
            for k = search_pos_start, search_pos_end do
              fantom_arr_stretched = F_stretch_array2(fantom_arr,  block_ids[i+1]-block_ids[i]+1, k-block_ids[i])
              diff[k - search_pos_start+1] = F_find_arrays_com_diff(ref_arr, block_ids[i], fantom_arr_stretched)
            end
            min_id_diff = F_find_min_value(diff)+search_pos_start
            --[[msg('---------------') 
            msg(min_id_diff)     
            msg(block_ids[i+1])]]
            sm_table[#sm_table+1] =  
                {min_id_diff *  window_sec,
                  (block_ids[i+1]+2) * window_sec}
                  
            block_ids[i+1] = min_id_diff
          end
      end -- end loop blocks
    --msg('test')
    return sm_table
  end    
    
-----------------------------------------------------------------------   
  function ENGINE_set_stretch_markers(take_id, str_mark_table, val)
    if str_mark_table == nil then return nil end
    if takes_t ~= nil and takes_t[take_id] ~= nil then
      local take = reaper.SNM_GetMediaItemTakeByGUID(0, takes_t[take_id].guid)
      if take ~= nil then       
        
        reaper.DeleteTakeStretchMarkers(take, 0, #str_mark_table + 1)
       
        reaper.SetTakeStretchMarker(take, -1, 0, takes_t[take_id].offset)
        for i = 1, #str_mark_table do
        
          set_pos = str_mark_table[i][1]-(takes_t[take_id].pos-takes_t[1].pos)
          src_pos = str_mark_table[i][2]-(takes_t[take_id].pos-takes_t[1].pos)+takes_t[take_id].offset
          set_pos = src_pos - takes_t[take_id].offset - ((src_pos - takes_t[take_id].offset) - set_pos) * val
                    
          if last_src_pos ~= nil and last_set_pos ~= nil then
            -- check for negative stretch markers
            if (src_pos - last_src_pos) / (set_pos - last_set_pos ) > 0 then
              reaper.SetTakeStretchMarker(take, -1, set_pos,src_pos)             
              last_src_pos = src_pos
              last_set_pos = set_pos
            end
           else
            reaper.SetTakeStretchMarker(take, -1, set_pos,src_pos)             
            last_src_pos = src_pos
            last_set_pos = set_pos
          end
          
        end
        reaper.SetTakeStretchMarker(take, -1, takes_t[take_id].len)
        
      end
    end
    reaper.UpdateArrange()
  end

-----------------------------------------------------------------------     
  function TEST_draw_points(xywh, reaperarray)
    if reaperarray ~= nil then
      local arr_size = reaperarray.get_alloc()
      local coeff = 1
      gfx.a = 1
      --gfx.rect(xywh[1],xywh[2],xywh[3],xywh[4],0)
      gfx.x = xywh[1]
      gfx.y = xywh[2]+xywh[4]
      for i = 1, arr_size do
        gfx.line(xywh[1] + xywh[3]*(i/arr_size),
                     xywh[2],
                     xywh[1] + xywh[3]*(i/arr_size),
                     xywh[2]+xywh[4]*reaperarray[i])      
      end
    end
  end  
  
----------------------------------------------------------------------- 
  function GUI_item_display(objects, gui, xywh, reaperarray, is_ref, pointsarray, name, font)
    if reaperarray == nil then return end
    local arr_size = reaperarray.get_alloc()
    local x=xywh[1]
    local y=xywh[2]
    local w=xywh[3]
    local h=xywh[4]
     -- draw item back gradient from buf 7
       gfx.a = 0.4
       gfx.blit(7, 1, 0, -- backgr
                0,0,objects.main_w, objects.main_h,
                xywh[1],xywh[2],xywh[3], xywh[4], 0,0)

      -- draw envelope  
          gfx.a = 0.7
          F_Get_SSV(gui.color.white, true) 
          local drawscale = 0.9
          gfx.x = x
          gfx.y = y
          for i=1, arr_size-1, 1 do
            local data_t_it = reaperarray[i]*drawscale
            local data_t_it2 = reaperarray[i+1]*drawscale
            local const = 0
            local st_x = x+i*w/arr_size
            local end_x = x+(i+1)*w/arr_size+const              
            if end_x > x+w then end_x = x+w end
            if end_x < x then end_x = x end
            if is_ref then 
              gfx.a = 0.2
              gfx.triangle(st_x,    y+h-h*data_t_it,
                         end_x,y+h-h*data_t_it2,
                         end_x,y+h,
                         st_x,    y+h )
             else
              gfx.a = 0.8
              F_Get_SSV(gui.color.white, true) 
              gfx.triangle(st_x,    y+h*data_t_it,
                           end_x,y+h*data_t_it2,
                           end_x,y,
                           st_x,    y )   
              gfx.a = 0.4
              if data.current_window == 1 then F_Get_SSV(gui.color.green, true) end
              if data.current_window == 2 then F_Get_SSV(gui.color.blue, true) end
              gfx.lineto(x+(i+1)*w/arr_size, y-h*data_t_it2)
            end                    
          end -- envelope building
          
          
          gfx.x,gfx.y = x,y
          gfx.blurto(x+w,y+h)
          gfx.muladdrect(x-1,y,w+2,h,
            1,--mul_r,
            1.0,--mul_g,
            1.0,--mul_b,
            1.5,--mul_a,
            0,--add_r,
            0,--add_g,
            0,--add_b,
            0)--add_a)
             
    -- draw blocks
      if data.current_window == 1 then 
        if pointsarray ~= nil then
          local pointsarr_size = reaperarray.get_alloc(pointsarray)
          -- get blocks
            local bl_t = {}
            for i = 1, pointsarr_size do
              if pointsarray[i] == 1 then bl_t[#bl_t+1] = i end
            end  
          
          gfx.a = 0.4
          
          if #bl_t%2 == 0 then -- ok
            F_Get_SSV(gui.color.green, true)            
            for i = 1, #bl_t, 2 do
              gfx.rect(x + w/pointsarr_size * bl_t[i],
                       y,
                       w/pointsarr_size * (bl_t[i+1]- bl_t[i]),
                       h)
            end
           else
            F_Get_SSV(gui.color.red, true)            
            for i = 1, #bl_t, 2 do
              if bl_t[i+1] == nil then bl_t[i+1] = pointsarr_size end
              gfx.rect(x + w/pointsarr_size * bl_t[i],
                       y,
                       w/pointsarr_size * (bl_t[i+1]- bl_t[i]),
                       h)
            end            
          end
        end
      end
      
      -- draw sep points
        if data.current_window == 2 then 
          if pointsarray ~= nil then
            local pointsarr_size = reaperarray.get_alloc(pointsarray)
            local tri_h = 5
            local tri_w = tri_h
            F_Get_SSV(gui.color.blue, true) 
            gfx.a = 0.4
            for i = 1, pointsarr_size - 1 do
              if pointsarray[i] == 1 then
                gfx.line(x + i*w/pointsarr_size,
                          y,
                          x + i*w/pointsarr_size,
                          y+h - tri_h - 1)
                gfx.triangle(x + i*w/pointsarr_size, y+h-tri_h,
                             x + i*w/pointsarr_size, y+h,
                             x + i*w/pointsarr_size + tri_w, y+h)
              end
            end  
          end --pointsarray ~= nil then
        end --if data.current_window == 2 then 

      -- back
        gfx.a = 0.4
        gfx.blit(3, 1, 0, --backgr
          0,0,objects.main_w, objects.main_h,
          xywh[1],xywh[2],xywh[3],xywh[4], 0,0) 
                    
        
  end
  
        ----------------------------------------------------------------------- 
        function GUI_button(objects, gui, xywh, name, issel, font) local w1_sl_a
          gfx.y,gfx.x = 0,0         
          -- frame
            gfx.a = 1
            F_Get_SSV(gui.color.white, true)
            --gfx.rect(xywh[1],xywh[2],xywh[3], xywh[4]+1, 0 , gui.aa)
            
          -- back
            if issel then gfx.a = 0.8 else gfx.a = 0.2 end
            gfx.blit(3, 1, 0, --backgr
              0,0,objects.main_w, objects.main_h,
              xywh[1],xywh[2],xywh[3],xywh[4], 0,0) 
            
          -- txt              
            
            gfx.setfont(1, gui.fontname, font)
            if issel then
              gfx.a = gui.b_sel_text_alpha
              F_Get_SSV(gui.color.black, true)
             else
              gfx.a = gui.b_sel_text_alpha_unset
              F_Get_SSV(gui.color.white, true)
            end
            local measurestrname = gfx.measurestr(name)
            local x0 = xywh[1] + (xywh[3] - measurestrname)/2
            local y0 = xywh[2] + (xywh[4] - gui.b_sel_fontsize)/2
            gfx.x, gfx.y = x0,y0 
            gfx.drawstr(name)  
        end

        -----------------------------------------------------------------------         
        function GUI_button2(objects, gui, xywh, name, issel, font, text_alpha, color_str) local w1_sl_a
          gfx.y,gfx.x = 0,0         
          -- frame
            gfx.a = 0.1
            F_Get_SSV(gui.color.white, true)
            gfx.rect(xywh[1],xywh[2],xywh[3], xywh[4], 0 , gui.aa)
            
          -- back
            if issel then gfx.a = 0.7 else gfx.a = 0.3 end
            gfx.blit(3, 1, 0, --backgr
              0,0,objects.main_w, objects.main_h,
              xywh[1],xywh[2],xywh[3],xywh[4], 0,0) 
            
          -- txt              
            
            gfx.setfont(1, gui.fontname, font)
            gfx.a = text_alpha
            F_Get_SSV(gui.color[color_str], true)
            local measurestrname = gfx.measurestr(name)
            local x0 = xywh[1] + (xywh[3] - measurestrname)/2
            local y0 = xywh[2] + (xywh[4] - gui.b_sel_fontsize)/2
            gfx.x, gfx.y = x0,y0 
            gfx.drawstr(name)  
        end        

                
        ----------------------------------------------------------------------- 
        function GUI_slider(objects, gui,  xywh, val, alpha, col)
          if val == nil then val = 0 end
          gfx.y,gfx.x = 0,0         
          
          -- frame
            gfx.a = 0.1 * alpha
            F_Get_SSV(gui.color.white, true)
            gfx.rect(xywh[1],xywh[2],xywh[3], xywh[4], 1 , gui.aa) 
            
          -- center line
            gfx.a = 0.5 * alpha
            F_Get_SSV(gui.color[col], true)
            local sl_w = 3
            gfx.rect(xywh[1],xywh[2]+ (xywh[4]- sl_w) / 2,xywh[3], sl_w, 1 , gui.aa)  

          -- blit grad             
            local handle_w = 20
            local x_offs = xywh[1] + (xywh[3] - handle_w) * val            
            gfx.a = 0.8 * alpha
            gfx.blit(3, 1, math.rad(180), --backgr
              0,0,objects.main_w, objects.main_h,
              x_offs,xywh[2],handle_w/2,xywh[4], 0,0)
            gfx.blit(3, 1, math.rad(0), --backgr
              0,0,objects.main_w, objects.main_h,
              x_offs+handle_w/2,xywh[2],handle_w/2,xywh[4], 0,0) 
              
          -- grid
            local gr_h = 20
            for i = 0, 1, 0.1 do
              gfx.a = 0.3 * alpha
              F_Get_SSV(gui.color.white, true)
              gfx.line(handle_w/2 + xywh[1] + (xywh[3]-handle_w) * i, xywh[2] + xywh[4]/2 - gr_h*i - 1,
                       handle_w/2 + xywh[1] + (xywh[3]-handle_w) * i, xywh[2] + xywh[4]/2 + gr_h*i-1 )
            end            
        end
        
----------------------------------------------------------------------- 
        function GUI_text(xywh, gui, objects, f_name, f_size, name, has_frame)
          gfx.setfont(1, f_name, f_size) 
          local measurestrname = gfx.measurestr(name)
          local x0 = xywh[1] + (xywh[3] - measurestrname)/2
          local y0 = xywh[2]+(xywh[4]-gfx.texth)/2
          
          if has_frame then 
            -- text back
            gfx.a = 0.9
            F_Get_SSV(gui.color.back, true)
            gfx.rect(x0-objects.x_offset,y0,measurestrname+objects.x_offset*2,gfx.texth)  
          end
          
          -- text
          gfx.x, gfx.y = x0,y0 
          gfx.a = 0.9
          F_Get_SSV(gui.color.white, true)
          gfx.drawstr(name)
          
            
        end
                  
-----------------------------------------------------------------------   
  function DEFINE_GUI_buffers()
    local is_sel, b_col
    local objects = DEFINE_objects()
    update_gfx_minor = true
    
    -- GUI variables 
      local gui = {}
      gui.aa = 1
      gfx.mode = 0
      gui.fontname = 'Calibri'
      gui.fontsize = 21      
      if OS == "OSX32" or OS == "OSX64" then gui.fontsize = gui.fontsize - 5 end
      
      -- selector buttons
        gui.b_sel_fontsize = gui.fontsize - 2
        gui.b_sel_text_alpha = 1
        gui.b_sel_text_alpha_unset = 0.7
        
      -- reg buttons
        gui.b_text_alpha = 0.8
        gui.b3_text_alpha = 0.8
      -- takenames
        gui.b_takenames_fontsize = gui.fontsize - 4
      
      gui.color = {['back'] = '51 51 51',
                    ['back2'] = '51 63 56',
                    ['black'] = '0 0 0',
                    ['green'] = '102 255 102',
                    ['blue'] = '127 204 255',
                    ['white'] = '255 255 255',
                    ['red'] = '204 76 51',
                    ['green_dark'] = '102 153 102'
                  }           
                       
      gui.window = {'Phrases',
                    'Syllables',
                    'Phase',
                    'Volume / Pan',
                    'Pitch',
                    'Spectrum',
                    'Tempo',
                    'Split',                    
                    'About'}
      
    
    
      ----------------------------------------------------------------------- 
          
    -- data.current_window
      -- 1 phrases items
      -- 2 syllables
      -- 9 about
      
    -- buffers
      -- 1 main back
      -- 2 select windows
      -- 3 button back gradient
      -- 4 wind 1
      -- 5 wait window
      -- 6 envelopes
      -- 7 buffer back
      -- 8 about
        
    -- buf1 background   
      if update_gfx then    
        fdebug('DEFINE_GUI_buffers_1-mainback')  
        gfx.dest = 1
        gfx.setimgdim(1, -1, -1)  
        gfx.setimgdim(1, objects.main_w, objects.main_h) 
        gfx.a = 0.92
        F_Get_SSV(gui.color.back, true)
        gfx.rect(0,0, objects.main_w, objects.main_h,1)
      end
    
    -- buf3 -- buttons back gradient
      if update_gfx then    
        fdebug('DEFINE_GUI_buffers_3-buttons back')  
        gfx.dest = 3
        gfx.setimgdim(3, -1, -1)  
        gfx.setimgdim(3, objects.main_w, objects.main_h)  
           gfx.a = 1
           local r,g,b,a = 0.9,0.9,1,0.6
           gfx.x, gfx.y = 0,0
           local drdx = 0.00001
           local drdy = 0
           local dgdx = 0.0001
           local dgdy = 0.0003     
           local dbdx = 0.00002
           local dbdy = 0
           local dadx = 0.0003
           local dady = 0.0004       
           gfx.gradrect(0,0,objects.main_w, objects.main_h, 
                        r,g,b,a, 
                        drdx, dgdx, dbdx, dadx, 
                        drdy, dgdy, dbdy, dady)
      end  
    
    -- buf2 -- selector buttons
      if update_gfx then    
        fdebug('DEFINE_GUI_buffers_2-common buttons')  
        gfx.dest = 2
        gfx.setimgdim(2, -1, -1)  
        gfx.setimgdim(2, objects.main_w_nav, objects.main_h)
        -- black frame
          gfx.a = 0.9
          F_Get_SSV(gui.color.black, true)
          gfx.rect(0,0,objects.main_w_nav, objects.main_h)
        -- buttons
          for i = 1, objects.b_count do
            if data.current_window == i then is_sel = true else is_sel = false end
            GUI_button(objects, gui, {0, objects.b_h * (i-1), objects.main_w_nav, objects.b_h },
               gui.window[i],is_sel,gui.b_sel_fontsize)
          end
      end
    
    -- buf 4 -- general buttons / sliders / info
      if update_gfx_minor then
        if data.current_window == 1 
        or data.current_window == 2 
        then
          gfx.dest = 4
          gfx.setimgdim(4, -1, -1)  
          gfx.setimgdim(4, objects.main_w, objects.main_h)
          
          GUI_button2(objects, gui, objects.b_setup,'Settings', mouse.context == 'w1_settings_b', gui.b_sel_fontsize, 0.7, 'white') 
          GUI_button2(objects, gui, objects.b_tips,'Tips / Help', mouse.context == 'w1_tips_b', gui.b_sel_fontsize, 0.7, 'white') 
          if data.current_window == 1 then b_col = 'green' end
          if data.current_window == 2 then b_col = 'blue' end  
            GUI_button2(objects, gui, objects.b_get, 'Get & Prepare selected takes', 
            mouse.context == 'w1_get_b',    gui.b_sel_fontsize, 0.8, b_col) 
          
          if takes_t ~= nil and takes_t[2] ~= nil then
            GUI_slider(objects, gui, objects.b_slider, w1_slider, 1,b_col)
            -- display navigation
              if mouse.context == 'w1_disp' then
              -- take names
                GUI_text(objects.disp_ref_text, gui, objects, 
                  gui.fontname, gui.b_takenames_fontsize, 'Reference: '..takes_t[1].name:sub(0,30), true)              
                local d_name = 'Dub: '
                if takes_t[3] ~= nil then d_name = 'Dubs ('..math.floor(data.current_take-1)..'/'..(#takes_t - 1)..'): ' end
                GUI_text(objects.disp_dub_text, gui, objects, 
                  gui.fontname, gui.b_takenames_fontsize, d_name..takes_t[data.current_take].name:sub(0,30), true)
              end
            -- display cursor position
              gfx.a = 0.9
              F_Get_SSV(gui.color.red, true)
              gfx.line(F_limit(objects.disp[1] + objects.disp[3] / takes_t[1].len * (play_pos - takes_t[1].pos), 
                        objects.disp[1], objects.disp[1] + objects.disp[3]),
                        objects.disp[2],
                       F_limit(objects.disp[1] + objects.disp[3] / takes_t[1].len * (play_pos - takes_t[1].pos), 
                        objects.disp[1], objects.disp[1] + objects.disp[3]),
                        objects.disp[2]+objects.disp[4])
          end
 
        end -- data.current_window  
      end

    -- buf 6 static envelopes buttons
      if update_gfx then 
        if data.current_window == 1 
        or data.current_window == 2 
        then  
          fdebug('DEFINE_GUI_buffers_6-envelopes')      
          gfx.dest = 6
          gfx.setimgdim(6, -1, -1)  
          gfx.setimgdim(6, objects.main_w, objects.main_h)
                                    
          if takes_t ~= nil and  takes_t[2] ~= nil then
            GUI_item_display(objects, gui, objects.disp_ref , takes_arrays[1], true, takes_points[1]) 
            GUI_item_display(objects, gui, objects.disp_dub , takes_arrays[data.current_take], false ,takes_points[data.current_take])
          end  
        end --if data.current_window == 1 
      end
    
    
    -- buf 5 wait
      if trig_process ~= nil and trig_process == 1 then
        gfx.dest = 5
        gfx.setimgdim(5, -1, -1)  
        gfx.setimgdim(5, objects.main_w, objects.main_h) 
        gfx.a = 0.93
        F_Get_SSV(gui.color.back, true)
        gfx.rect(0,0, objects.main_w, objects.main_h,1)  
        F_Get_SSV(gui.color.white, true)    
        local str = 'Analyzing takes. Please wait...'
        gfx.setfont(1, gui.fontname, gui.fontsize)
        gfx.x = (objects.main_w - gfx.measurestr(str))/2
        gfx.y = (objects.main_h-gfx.texth)/2
        gfx.drawstr(str)
      end
      
    -- item envelope gradient
      if update_gfx then 
        if data.current_window == 1 
        or data.current_window == 2 
        then
          gfx.dest = 7  
          gfx.setimgdim(7, -1, -1)
          gfx.setimgdim(7, objects.main_w, objects.main_h)
          gfx.gradrect(0,0, objects.main_w, objects.main_h, 1,1,1,0.8, 0,0,0,0.0001, 0,0,0,-0.005)
        end --if data.current_window == 1 
      end
    
    
    if debug_mode == 1 then 
      -- buf19 test
        if update_gfx or update_gfx_minor then    
          gfx.dest = 19
          gfx.setimgdim(19, -1, -1)
          gfx.setimgdim(19, objects.main_w, objects.main_h)
        end
      end
      
    -- about
      if update_gfx then 
        if data.current_window == 9 then
          gfx.dest = 8  
          gfx.setimgdim(8, -1, -1)
          gfx.setimgdim(8, objects.main_w, objects.main_h)

          -- main about
          gfx.a = 0.8
          gfx.setfont(1, gui.fontname, gui.fontsize)
          F_Get_SSV(gui.color.white, true) 
          gfx.x = objects.main_w_nav + objects.x_offset
          gfx.y = objects.y_offset
          gfx.drawstr('Warping Tool\n'..
                         'Lua script for Cockos REAPER\n'..
                         'Written by Michael Pilyavskiy (Russia)\n'..
                         'Version '..vrs)
          
          --[[local w_sep = (objects.main_w - objects.main_w_nav) /3
          gfx.x = objects.main_w_nav + objects.x_offset
          gfx.y = objects.about_links_offs
          gfx.drawstr('Contacts:\n\n')
          F_Get_SSV(gui.color.green, true) 
          gfx.x = objects.main_w_nav + objects.x_offset
          gfx.drawstr('Soundcloud\n'..
                      'PromoDJ\n'..
                      'GitHub\n'..
                      'VK')

          gfx.x = objects.main_w_nav + objects.x_offset + w_sep
          gfx.y = objects.about_links_offs
          F_Get_SSV(gui.color.white, true) 
          gfx.drawstr('Support:\n\n')
          F_Get_SSV(gui.color.green, true) 
          gfx.x = objects.main_w_nav + objects.x_offset + w_sep
          gfx.drawstr('Cockos thread\n'..
                      'RMM thread')
                      
          gfx.x = objects.main_w_nav + objects.x_offset + w_sep*2
          gfx.y = objects.about_links_offs
          F_Get_SSV(gui.color.white, true) 
          gfx.drawstr('Donation:\n\n')
          F_Get_SSV(gui.color.green, true) 
          gfx.x = objects.main_w_nav + objects.x_offset + w_sep*2
          gfx.drawstr('Donate via PayPal')                      
                  ]]    

        end
      end    
    ------------------
    -- common buf20 --
    ------------------
      gfx.dest = 20   
      gfx.setimgdim(20, -1,-1)
      gfx.setimgdim(20, objects.main_w, objects.main_h)
      
      -- common
        gfx.a = 1
        gfx.blit(1, 1, 0, -- backgr
          0,0,objects.main_w, objects.main_h,
          0,0,objects.main_w, objects.main_h, 0,0) 
        gfx.a = 1
        gfx.blit(2, 1, 0, -- buttons
          0,0,objects.main_w, objects.main_h,
          0,0,objects.main_w, objects.main_h, 0,0)           
          
      -- wind 1 phrase
        if data.current_window == 1 
        or data.current_window == 2 
        then
          gfx.blit(6, 1, 0, -- main window  static
            0,0,objects.main_w, objects.main_h,
            0,0,objects.main_w, objects.main_h, 0,0) 
          gfx.blit(4, 1, 0, -- main window dynamic
            0,0,objects.main_w, objects.main_h,
            0,0,objects.main_w, objects.main_h, 0,0)           
            
          if  trig_process ~= nil and trig_process == 1 then
            gfx.blit(5, 1, 0, --wait
            0,0,objects.main_w, objects.main_h,
            0,0,objects.main_w, objects.main_h, 0,0)   
          end
        end
        
      -- wind 9 about
        if data.current_window == 9 then
          gfx.blit(8, 1, 0, -- main window  static
            0,0,objects.main_w, objects.main_h,
            0,0,objects.main_w, objects.main_h, 0,0) 
        end        
        
        
        gfx.blit(19, 1, 0, --TEST
          0,0,objects.main_w, objects.main_h,
          0,0,objects.main_w, objects.main_h, 0,0)  
              
    update_gfx = false
  end

-----------------------------------------------------------------------    
  function GUI_DRAW()
    local objects = DEFINE_objects()
    --fdebug('GUI_DRAW')
     
    -- common buffer
      gfx.dest = -1   
      gfx.a = 1
      gfx.x,gfx.y = 0,0
      gfx.blit(20, 1, 0, 
        0,0, objects.main_w, objects.main_h,
        0,0, objects.main_w, objects.main_h, 0,0)
        
    gfx.update()
  end
  
-----------------------------------------------------------------------     
  function MOUSE_match(b)
    if mouse.mx > b[1] and mouse.mx < b[1]+b[3]
      and mouse.my > b[2] and mouse.my < b[2]+b[4] then
     return true 
    end 
  end 

----------------------------------------------------------------------- 
  function F_form_menu_item(default_data, name, val, type)
      
    if type == 'ms' then 
      function F_ret_str(x) return math.floor(x*1000)..'ms ' end 
     elseif type == 'db' then 
      function F_ret_str(x) return math.floor(x)..'db ' end 
    end 
    
    local outstr = '|'..name..': '..
      F_ret_str(data[val])..
      '(Default = '..F_ret_str(default_data[val])..')'
    
    return outstr
  end

-----------------------------------------------------------------------   
  function F_menu_item_response(menuret, id, lim1, lim2, sectionname, keyname, type,val) 
    local retval, num, in_value, ret
      if menuret == id then
        if type == 'ms' then in_value = tostring(math.floor(data[val]*1000)) else 
          in_value = tostring(math.floor(data[val])) end
        ret, retval = reaper.GetUserInputs(sectionname, 1, keyname, in_value)
        if ret and tonumber(retval) ~= nil 
          and tonumber(retval) ~= tonumber(in_value) then
          if type == 'ms' then
            num = F_limit(tonumber(retval), lim1, lim2) / 1000
           elseif type == 'db' then
            num = F_limit(tonumber(retval), lim1, lim2)
          end
          data[val] = num
          ENGINE_clear_takes_data()
          ENGINE_set_ini(data,config_path)
        end
      end  
  end
   
-----------------------------------------------------------------------   
  function GUI_menu_settings1() local menuret 
    local default_data = DEFINE_global_variables()
    
    
    local menuret = gfx.showmenu(
      'Restore defaults for phrases alighment'..
      '|'..F_form_menu_item(default_data, 'Noise threshold',  'threshold1', 'db')..
      F_form_menu_item(default_data, 'Minimal phrase length', 'min_phrase_time1', 'ms')..
      '|'..F_form_menu_item(default_data, 'Search area',      'max_search_area1', 'ms')
      
      )
    
    -- BASIC
    
      if menuret == 1 then -- restore defaults
        data.max_search_area1 = default_data.max_search_area1
        data.min_phrase_time1 = default_data.min_phrase_time1
        data.threshold1 = default_data.threshold1
        ENGINE_set_ini(data, config_path)
        ENGINE_clear_takes_data() 
      end
      
      F_menu_item_response(menuret, 2, -120, -20, 'Phrases alighnment','Noise threshold', 'db', 'threshold1')  
      F_menu_item_response(menuret, 3, 300, 10000, 'Phrases alighnment','Min. phrase length', 'ms', 'min_phrase_time1')    
      F_menu_item_response(menuret, 4, 100, 2000, 'Phrases alighnment','Search area', 'ms', 'max_search_area1')
      
  end

-----------------------------------------------------------------------   
  function GUI_menu_settings2() local menuret 
    local default_data = DEFINE_global_variables()
    
    
    local menuret = gfx.showmenu(
      'Restore defaults for syllables alighment'..
      '|'..F_form_menu_item(default_data, 'Noise threshold','threshold2', 'db')
      ..F_form_menu_item(default_data, 'Rise area gain','threshold_rise2', 'db')
      ..F_form_menu_item(default_data, 'Rise area','rise_area2', 'ms')
      ..F_form_menu_item(default_data, 'Filter area','filter_area2', 'ms')
      ..'|'..F_form_menu_item(default_data, 'Search area','max_search_area2', 'ms')
      
      )
    
    -- BASIC
    
      if menuret == 1 then -- restore defaults
        data.threshold2 = default_data.threshold2
        data.threshold_rise2 = default_data.threshold_rise2     
        data.rise_area2 = default_data.rise_area2
        data.filter_area2 = default_data.filter_area2
        data.max_search_area2 = default_data.max_search_area2
        
        ENGINE_clear_takes_data() 
        ENGINE_set_ini(data,config_path)
      end
      
      F_menu_item_response(menuret, 2, -120, -20, 'Syllables alighnment','Noise threshold', 'db', 'threshold2')  
      F_menu_item_response(menuret, 3, 10, 120, 'Syllables alighnment','Rise area threshold', 'db', 'threshold_rise2')
      F_menu_item_response(menuret, 4, 10, 500, 'Syllables alighnment','Rise area', 'ms', 'rise_area2')  
      F_menu_item_response(menuret, 5, 10, 500, 'Syllables alighnment','Filter area', 'ms', 'filter_area2')  
      F_menu_item_response(menuret, 6, 10, 500, 'Syllables alighnment','Search area', 'ms', 'max_search_area2')  
      
      
  end
  
-----------------------------------------------------------------------    
  function GUI_menu_display(takes_t)
  
              local takesstr = ''
              for i = 1, #takes_t do
                if i == 1 then
                  takesstr = takesstr..'Reference: '..takes_t[i].name..'||'
                 else
                  takesstr = takesstr..'Dub #'..(i-1)..': '..takes_t[i].name..'|'
                end
              end
              
              local ret_menu = gfx.showmenu(takesstr)
              if ret_menu >1 then 
                data.current_take = ret_menu
                update_gfx = true
              end 
  end

-----------------------------------------------------------------------     
  function ENGINE_clear_takes_data() 
        -- clear data
          takes_t = {}
          takes_arrays = {}
          takes_points = {}
          str_markers_t = {}
  end
  
-----------------------------------------------------------------------   
  function MOUSE_get()
    local objects = DEFINE_objects()
    local ret -- ENGINE_prepare_takes response
    mouse.mx = gfx.mouse_x
    mouse.my = gfx.mouse_y
    mouse.LMB_state = gfx.mouse_cap&1 == 1 
    mouse.RMB_state = gfx.mouse_cap&2 == 2 
    mouse.MMB_state = gfx.mouse_cap&64 == 64
    mouse.LMB_state_doubleclick = false
    mouse.Ctrl_LMB_state = gfx.mouse_cap&5 == 5 
    mouse.Ctrl_state = gfx.mouse_cap&4 == 4 
    mouse.Alt_state = gfx.mouse_cap&17 == 17 -- alt + LB
    mouse.wheel = gfx.mouse_wheel
    if not mouse.LMB_state  then mouse.context = nil end
    
    if mouse.last_LMB_state and not mouse.LMB_state then mouse.last_touched = nil end
    
    -- change windows
      if mouse.LMB_state and not mouse.last_LMB_state 
       and MOUSE_match({0,0, objects.main_w_nav, objects.main_h}) then
        data.current_window = math.ceil(objects.b_count * mouse.my / objects.main_h)
        ENGINE_set_ini(data, config_path)
        update_gfx = true
        
        ENGINE_clear_takes_data()
      end
    
    -- get takes
      if data.current_window == 1 
      or data.current_window == 2 then
        -- display
          if MOUSE_match(objects.disp) then mouse.context = 'w1_disp' end
          if takes_t~= nil and takes_t[2] ~= nil then 
            if MOUSE_match(objects.disp) and mouse.LMB_state and not mouse.last_LMB_state then
              gfx.x = mouse.mx
              gfx.y = mouse.my
              GUI_menu_display(takes_t)
            end
          end
          
        -- settings button 
          if MOUSE_match(objects.b_setup) then mouse.context = 'w1_settings_b' end
          if MOUSE_match(objects.b_setup) 
            and mouse.LMB_state 
            and not mouse.last_LMB_state 
            then            
            gfx.x = mouse.mx
            gfx.y = mouse.my
            _G['GUI_menu_settings'..data.current_window]()
          end
          
        -- Tips button 
          if MOUSE_match(objects.b_tips) then mouse.context = 'w1_tips_b' end
          if MOUSE_match(objects.b_tips) 
            and mouse.LMB_state 
            and not mouse.last_LMB_state 
            then
            reaper.MB(tips[data.current_window].text, tips[data.current_window].title, 0)
          end          
                
        -- get button 
          if MOUSE_match(objects.b_get) then mouse.context = 'w1_get_b' end
          if MOUSE_match(objects.b_get) 
            and mouse.LMB_state 
            and not mouse.last_LMB_state 
           then
            if trig_process == nil then trig_process = 1 end
            
          end
          
          if trig_process ~= nil and trig_process == 1 and not mouse.LMB_state then 
            ret = ENGINE_prepare_takes()
            if ret == 1 then
              takes_t = ENGINE_get_takes()
              if #takes_t ~= 1 and #takes_t >= 2 then
                str_markers_t = {}           
                for i = 1, #takes_t do 
                  takes_arrays[i] = ENGINE_get_take_data(i, 
                    data.scaling_pow1) 
                  if i > 1 then
                    takes_points[i] = 
                      _G['ENGINE_get_take_data_points'..data.current_window]
                        (takes_arrays[i],data.global_window_sec)
                    str_markers_t[i] = 
                      _G['ENGINE_compare_data'..data.current_window]
                        (takes_arrays[1], takes_arrays[i], takes_points[i],
                        data.global_window_sec )
                  end
                end
              end
            end 
            update_gfx = true 
            trig_process = nil
          end
          
          
        -- strength / apply slider 1 
          if takes_t ~= nil then 
            if MOUSE_match(objects.b_slider)
              and mouse.LMB_state 
              and not mouse.last_LMB_state then 
                mouse.context = 'w1_slider' 
            end
            if mouse.context == 'w1_slider' then
              w1_slider = F_limit((mouse.mx - objects.b_slider[1]) / objects.b_slider[3],0,1 )
              --msg(w1_slider)
              for i = 2, #takes_t do 
                ENGINE_set_stretch_markers(i, str_markers_t[i], w1_slider)
              end
            end
          end
             
          
      end -- window 1 macro alighn
      
                  
    
    mouse.last_LMB_state = mouse.LMB_state  
    mouse.last_RMB_state = mouse.RMB_state
    mouse.last_MMB_state = mouse.MMB_state 
    mouse.last_Ctrl_LMB_state = mouse.Ctrl_LMB_state
    mouse.last_Ctrl_state = mouse.Ctrl_state
    mouse.last_wheel = mouse.wheel      
  end
  
----------------------------------------------------------------------- 
  function MAIN_defer()
    DEFINE_dynamic_variables()
    DEFINE_GUI_buffers()
    GUI_DRAW()
    MOUSE_get()
    if char == 27 then MAIN_exit() end  --escape
    if char == 32 then reaper.Main_OnCommandEx(40044, 0,0) end -- space-> transport play   
    if char ~= -1 then reaper.defer(MAIN_defer) else MAIN_exit() end
  end 
  
  function DEFINE_objects()
    -- GUI global
      local objects = {}
      objects.x_offset = 10
      objects.y_offset = 5
      objects.b_count = 9
      objects.b_h = 40
      objects.main_w = 600
      objects.main_h = objects.b_count * objects.b_h
      objects.main_w_nav = 130 -- width navigation zone
      objects.takes_name_h = 70 -- display H
      objects.takes_name_h2 = 20 -- display names
      objects.slider_h = 40
      objects.get_b_h = 40
      objects.b_setup_h = 20
      objects.tips_w = 100
      
    -- GUI main window
      
      objects.b_setup = {objects.main_w_nav + objects.x_offset,
                         objects.y_offset,
                         objects.main_w - (objects.main_w_nav + 2.5*objects.x_offset + objects.tips_w),
                         objects.b_setup_h}
      objects.b_tips = {objects.main_w - objects.x_offset - objects.tips_w,
                         objects.y_offset,
                         objects.tips_w,
                         objects.b_setup_h}                         
                         
                         
      objects.b_get = {objects.main_w_nav + objects.x_offset, objects.y_offset*2+objects.b_setup_h,
                          objects.main_w - objects.main_w_nav - 2 * objects.x_offset, 
                          objects.get_b_h}     
      objects.disp_ref = {objects.main_w_nav + objects.x_offset, 
                          objects.get_b_h + 3*objects.y_offset+objects.b_setup_h,
                          objects.main_w - objects.main_w_nav - 2 * objects.x_offset, 
                          objects.takes_name_h}
      objects.disp_ref_text = {objects.disp_ref[1],
                                objects.disp_ref[2]+objects.disp_ref[4]-objects.takes_name_h2,
                                objects.disp_ref[3],
                                objects.takes_name_h2}
      objects.disp_dub = {objects.main_w_nav + objects.x_offset, 
                        objects.get_b_h + objects.takes_name_h + objects.y_offset*3+objects.b_setup_h,
                       objects.main_w - objects.main_w_nav - 2 * objects.x_offset, 
                       objects.takes_name_h}    
      objects.disp_dub_text = {objects.disp_dub[1],
                                objects.disp_dub[2],
                                objects.disp_dub[3],
                                objects.takes_name_h2}               
      objects.disp = {objects.main_w_nav + objects.x_offset, 
                        objects.get_b_h + objects.y_offset*3+objects.b_setup_h,
                       objects.main_w - objects.main_w_nav - 2 * objects.x_offset, 
                       objects.takes_name_h*2}
      objects.b_slider = {objects.main_w_nav + objects.x_offset, 
                        2*objects.takes_name_h + 4*objects.y_offset+objects.get_b_h + objects.b_setup_h,
                          objects.main_w - objects.main_w_nav - 2 * objects.x_offset, 
                          objects.slider_h} 
      --[[objects.b_slider2 = {objects.main_w_nav + objects.x_offset, 
                          2*objects.takes_name_h + 5*objects.y_offset+objects.get_b_h + objects.b_setup_h + objects.slider_h,
                          objects.main_w - objects.main_w_nav - 2 * objects.x_offset, 
                          objects.slider_h}]]                           
    return objects
  end
    
-----------------------------------------------------------------------   
  function F_ret_ini_val2(content, ini_key, var, default_data)  
    local out_str ,str
    for line in content:gmatch("[^\r\n]+") do
      str = line:match(ini_key..'=.*')
      if str ~= nil then
        out_str = str:gsub(ini_key..'=','')
        break
      end
    end
    if out_str == nil or tonumber(out_str) == nil then out_str = default_data[var] end
    data[var] = tonumber(out_str)
  end
  
-----------------------------------------------------------------------  
  function ENGINE_set_ini(data, config_path)
    
    -------- LINK TO INI
    outstr = '[Global_variables]\n'..
      'current_window='..data.current_window..'\n'..
      
      '[wind1-phrase]\n'..
      'scaling_pow1='..data.scaling_pow1..'\n'..
      'threshold1='..data.threshold1..'\n'..
      'min_phrase_time1='..data.min_phrase_time1..'\n'..
      'max_search_area1='..data.max_search_area1..'\n'..
      
      '[wind2-syl]\n'..
      'threshold2='..data.threshold2..'\n'..
      'threshold_rise2='..data.threshold_rise2..'\n'..      
      'scaling_pow2='..data.scaling_pow2..'\n'..
      'rise_area2='..data.rise_area2..'\n'..
      'filter_area2='..data.filter_area2..'\n'..
      'max_search_area2='..data.max_search_area2..'\n'
    
    
    fdebug('ENGINE_set_ini >>>')    
    fdebug(outstr)
    
    local file = io.open(config_path,'w')
    file:write(outstr)
    file:close()
    
    update_gfx = true
  end   
       
-----------------------------------------------------------------------  
  function ENGINE_get_ini(config_path) --local ret, str
    update_gfx = true
    local file = io.open(config_path, 'r')
    content = file:read('*all')
    file:close()

    fdebug('ENGINE_get_ini <<< ') 
    fdebug(content)
        
    local default_data = DEFINE_global_variables()

    F_ret_ini_val2(content, 'current_window', 'current_window', default_data)
    
    F_ret_ini_val2(content, 'threshold1', 'threshold1', default_data)
    F_ret_ini_val2(content, 'scaling_pow1', 'scaling_pow1', default_data) 
    F_ret_ini_val2(content, 'min_phrase_time1', 'min_phrase_time1', default_data) 
    F_ret_ini_val2(content, 'max_search_area1', 'max_search_area1', default_data)    
    
    F_ret_ini_val2(content, 'threshold2', 'threshold2', default_data)
    F_ret_ini_val2(content, 'threshold_rise2', 'threshold_rise2', default_data) 
    F_ret_ini_val2(content, 'scaling_pow2', 'scaling_pow2', default_data) 
    F_ret_ini_val2(content, 'rise_area2', 'rise_area2', default_data) 
    F_ret_ini_val2(content, 'filter_area2', 'filter_area2', default_data)
    F_ret_ini_val2(content, 'max_search_area2', 'max_search_area2', default_data) 
    
  end
  
-----------------------------------------------------------------------
  function DEFINE_global_variables()
    
    
    takes_arrays = {}
    takes_points = {}
    
    -------- DEFINE VARS
    local data = {}
    data.current_window = 1 -- align items on start
    data.current_take = 2
    
    -- phrase alighn -- wind 1 settings
      data.scaling_pow1 = 0.25 -- pow for out_t
      data.threshold1 = -50 -- rise to add block
      data.min_phrase_time1 = 0.7 -- min time for phrase
      data.max_search_area1 = 0.3 -- search area

    -- syl alighn -- wind 2 settings
      data.threshold2 = -30 -- thld to add point
      data.threshold_rise2 = 50 -- thld of rise area
      data.scaling_pow2 = 0.25 -- pow for out_t
      data.rise_area2 = 0.3 -- for rise search
      data.filter_area2 = 0.05 -- filter closer points
      data.max_search_area2 = 0.05 -- search best fit for syllable
      
      
    return data
  end

-----------------------------------------------------------------------    
  function MAIN_search_ini(data)
    fdebug('MAIN_search_ini') 
    local reapath = reaper.GetResourcePath():gsub('\\','/')
    config_path = reapath..'/Scripts/mpl_Warping Tool.ini'
    local file = io.open(config_path, 'r')
    if file == nil then ENGINE_set_ini(data, config_path) else 
      ENGINE_get_ini(config_path) 
      file:close()
    end
    
  end
      
-----------------------------------------------------------------------  

  debug_mode = 0
  if debug_mode == 1 then msg("") end
    
  mouse = {}
  data = DEFINE_global_variables()
  MAIN_search_ini(data)
  objects = DEFINE_objects()
  gfx.init("mpl Warping tool // "..vrs..' beta', objects.main_w, objects.main_h, 0)
  objects = nil
  MAIN_defer()
  
  
---------------------------------------------------------------------------
 
  
  
-----------------------------------------------------------------------  
  -- stretch
  --[[ loop possible positions 
    for point = block_1st, block_3end - 1 do
      
      -- rebuild samples
      for i = block_1st, block_3end do
        coeff = (point - block_1st) / (block_2point - block_1st)
        id_before_point = math.floor((i - block_1st) / coeff + block_1st)
        coeff2 = (i - point) / (block_3end - point)
        id_after_point = math.floor(block_2point + (block_3end - block_2point) * coeff2)
        if i < point then 
          val1_t[i] = fantom_block_t[id_before_point] 
         else
          val1_t[i] = fantom_block_t[id_after_point] 
        end
      end
      
      -- add to fits t
      diff_com = 0
      for i = block_1st, block_3end do
        diff_com = diff_com + math.abs(val0_t[i]-val1_t[i])
      end
      diff_t[#diff_t+1] = diff_com  ]] 
      
      --------------------------------------------------------------------------------
  
    --[[
    -- data.min_phrase_time
    min_area = 7
    -- get blocks
      block_ids = {}
      for i = 1, #val1_points_t do
        if val1_points_t[i] == 1 then
          block_ids[#block_ids+1] = i
         else
        end
      end
      
      for block = 1, #block_ids - 2 do
        --block = 2
        diff_t = {}
        block_1st = block_ids[block]
        block_2point = block_ids[block+1]  
        block_3end = block_ids[block+2]    
        -- create fixed block
          fantom_block_t = {}      
          for i = block_1st, block_3end do fantom_block_t[i] = val1_t[i] end      
        
        -- loop possible positions 
          for point = block_1st, block_3end - 1 do
            
            -- rebuild samples
            for i = block_1st, block_3end do
              coeff = (point - block_1st) / (block_2point - block_1st)
              id_before_point = math.floor((i - block_1st) / coeff + block_1st)
              coeff2 = (i - point) / (block_3end - point)
              id_after_point = math.floor(block_2point + (block_3end - block_2point) * coeff2)
              if i < point then 
                val1_t[i] = fantom_block_t[id_before_point] 
               else
                val1_t[i] = fantom_block_t[id_after_point] 
              end
            end
            
            -- add to fits t
            diff_com = 0
            for i = block_1st, block_3end do
              diff_com = diff_com + math.abs(val0_t[i]-val1_t[i])
            end
            diff_t[#diff_t+1] = diff_com   
            
          end
          
        ---------------------------------
          
        -- check best fit
          min_dif0 = math.huge
          for i = 1, #diff_t do
            min_dif = math.min(diff_t [i], min_dif0)
            if min_dif ~= min_dif0 then min_dif0 = min_dif 
              min_dif_id = i 
            end
          end
          min_dif_id = min_dif_id + block_1st
          
        ---------------------------------
          
        -- apply fantom block with best fit
          point = min_dif_id - 1 
          for i = block_1st, block_3end do
            coeff = (point - block_1st) / (block_2point - block_1st)
            id_before_point = math.floor((i - block_1st) / coeff + block_1st)
            coeff2 = (i - point) / (block_3end - point)
            id_after_point = math.floor(block_2point + (block_3end - block_2point) * coeff2)
            if i < point then 
              val1_t[i] = fantom_block_t[id_before_point] 
             else
              val1_t[i] = fantom_block_t[id_after_point] 
            end
          end 
          
        ---------------------------------
          
        -- apply best fit to block id t
          val1_points_t[block_2point] = 0
          val1_points_t[min_dif_id] = 1          
          if math.abs(block_2point - min_dif_id) < min_area 
            and math.abs(block_2point - min_dif_id) > 1
            then
            --sm_table[#sm_table+1] = {block_2point, min_dif_id}
            sm_table[#sm_table+1] =  
              {min_dif_id*data.global_window_sec,
               block_2point*data.global_window_sec}
            block_ids[block+1] = min_dif_id  
          end
      end]]
      
-----------------------------------------------------------------------    
  
  
 ------------------------------------------------------------------------ 
  
  
  
  
  
  
  
   
 
 --[[ 
-----------------------------------------------------------------------
  f_unction F_conv_val2norm(v,v_min,v_max,inv)
    if inv then v_ret = ((v-v_max)/math.abs(v_min-v_max))+1 
     else   v_ret = (v - v_min) / (v_max-v_min)   end
    return v_ret
  end

-----------------------------------------------------------------------
  f_unction F_conv_norm2val(v_norm,v_min,v_max, inv)
    if inv then v = ((v_norm-1)*math.abs(v_min-v_max))+v_max
     else  v = v_norm*(v_max-v_min)+v_min   end
    return v
  end
  
-----------------------------------------------------------------------
  f_unction F_extract_table(table,use)
    if table ~= nil then
      a = table[1]
      b = table[2]
      c = table[3]
      d = table[4]
    end  
    if use == 'rgb' then gfx.r,gfx.g,gfx.b = a,b,c end
    if use == 'xywh' then x,y,w,h = a,b,c,d end
    return a,b,c,d
  end 
  
-----------------------------------------------------------------------  
  f_unction F_round(num, idp)
     local mult = 10^(idp or 0)
     return math.floor(num * mult + 0.5) / mult
  end

-----------------------------------------------------------------------    
  f_unction F_get_table_increments(table)
    if table ~= nil then
      t_incr = {0}
      val = 0
      for i =2, #table do
        t_val = table[i]
        t_val_prev = table[i-1]
        
        --
        if i > 2 then  t_val_prev2 = table[i-2] end
        if t_val > t_val_prev then incr_state = 1 else incr_state = -1 end
        if i > 2 then  
          if incr_state == 1 then 
            if t_val_prev > t_val_prev2 then val = val + 1 else val = 1 end end
          if incr_state == -1 then 
            if t_val_prev < t_val_prev2 then val = val - 1 else val = -1 end end    
         else
          if t_val > t_val_prev then val = 1 else val = -1 end
        end
        if val == nil then val = 0 end
        t_incr[i] = val        
      end
      return t_incr
    end    
  end
  
-----------------------------------------------------------------------
  f_unction DEFINE_default_variables()
    sel_items_t ={}
    ------------------------- 
    window_time = 0.02 -- sec
    ------------------------- 
    fft_size = 256 -- bins
    ------------------------- 
    fft_start_min = 1
    fft_start = 1 -- hp
    fft_start_max = 10
    ------------------------- 
    fft_end_min =  2
    fft_end = fft_size -- lp
    fft_end_max = fft_size
    ------------------------- 
    env_t_smooth_ratio = 0.0
    ------------------------- 
    mouse_res = 100 -- for knobs resolution
    mouse_res2 = 200 -- for sliders
    ------------------------- 
    strenght = 0
    -------------------------
    s_area1_min = 5 -- windows for RMS matching
    s_area1 = 20 -- windows for RMS matching
    s_area1_max = 300 -- windows for RMS matching
    -------------------------
    s_area2_min = 1 -- windows for detecting points /attack
    s_area2 = 1 -- windows for detecting points /attack
    s_area2_max = 100 -- windows for detecting points /attack  
    -------------------------
    max_timesel_smpls = 4410 -- max samples for peak matching
    -------------------------
    db_diff_min = 1 -- db difference for checking point rise within s_area2
    db_diff = 20
    db_diff_max = 40
    -------------------------
  end 
  
-----------------------------------------------------------------------  
  f_unction DEFINE_dynamic_variables()
    timesel_st,timesel_end = 
      reaper.GetSet_LoopTimeRange2(0, false, false, 0, 0, false)
    timesel_smpls = math.floor((timesel_end - timesel_st)*44100)
    
    if gui_params_set == 4 or gui_params_set == 5 then -- if match peaks
      if last_timesel_smpls ~= timesel_smpls then
        ENGINE3_find_offsets_by_peaks(false)
      end
    end 
    if fft_start > fft_end then fft_start = fft_end -1 end
  end
    
-----------------------------------------------------------------------
  f_unction ENGINE1_update_gui_data(cur_item)
    gui_ref_item_data_t, ref_item_name = 
      ENGINE1_get_item_data(sel_items_t[1],true, false)
    gui_cur_item_data_t, cur_item_name = 
      ENGINE1_get_item_data(sel_items_t[cur_item],false,false)
    update_gui_disp1 = true
    update_gui_disp2 = true
    gfx.setimgdim(1,-1,-1)
    gfx.setimgdim(2,-1,-1)
    gfx.setimgdim(6,-1,-1)
  end
  
-----------------------------------------------------------------------  
  f_unction ENGINE3_get_points(item_data_t)
    points_t = {}
    if item_data_t ~= nil then
      -- turn item_data_t into db values
        item_data_t_db = {}
        for i = 1, #item_data_t do item_data_t_db[i] = 20*math.log(item_data_t[i]) end
      -- if rise more than % of min point in 's_area2' windows
        -- fill start
          for i = 1, s_area2 do table.insert(points_t,0) end
        -- check for rise
          for i = 1+s_area2, #item_data_t_db do
            db_val_min = math.huge
            for j = i-s_area2, i-1 do
              db_val_min = math.min(db_val_min,item_data_t_db[j])
            end
            if math.abs(db_val_min - item_data_t_db[i]) > db_diff then
              points_t[i] = 1 else points_t[i] = 0 end
          end
    end
    return points_t  
      
      --[[
              
              for i = 2+s_area, #data_t-1 do
                if sm_data_t[i] == nil then
                  data_t_item = data_t[i]
                  data_t_item_area_min = math.huge
                  for j = i-s_area-1, i-1 do
                    data_t_item_area = data_t[j]            
                    data_t_item_area_min = math.min(data_t_item_area,data_t_item_area_min)
                  end
                  --test = data_t_item/data_t_item_area_min
                  if (data_t_item/data_t_item_area_min)*100 > rise_percent then
                   --if sm_data_t[#sm_data_t] == 0 then
                     table.insert(sm_data_t,1)
                    else
                     table.remove(sm_data_t,#sm_data_t)
                     table.insert(sm_data_t,0)
                     if data_t[i] > data_t[i+1] then
                       table.insert(sm_data_t,1)
                      else
                       table.insert(sm_data_t,0)
                       table.insert(sm_data_t,#sm_data_t, 1)
                     end
                   else
                    table.insert(sm_data_t,0)
                  end
                end
              end]]
      
      
    
      
      --[[fft_val_t2 = ENGINE1_get_item_data(item_guid, true, false)
      fft_val_t2_inc = F_get_table_increments(fft_val_t2)
      
      for i = 1, #fft_val_t2_inc do
        if fft_val_t2_inc[i] >= 4 then points_t[i] = 1 else points_t[i] = 0 end         
      end]]
      -- if rise area
      
        --[[for i = 1, s_area do
          table.insert(sm_data_t,0)
        end
        for i = 2+s_area, #data_t-1 do
          if sm_data_t[i] == nil then
            data_t_item = data_t[i]
            data_t_item_area_min = math.huge
            for j = i-s_area-1, i-1 do
              data_t_item_area = data_t[j]
              data_t_item_area_min = math.min(data_t_item_area,data_t_item_area_min)
            end
            if (data_t_item/data_t_item_area_min)*100 > rise_percent then
              -- check further area max point
              data_t_item_area_max = 0
              for k = i, i + s_area2 do
                if k < #data_t then
                  data_t_item_area_max0 = data_t_item_area_max
                  data_t_item_area = data_t[k]
                  data_t_item_area_max = math.max(data_t_item_area_max,data_t_item_area)
                  data_t_item_area_max1 = data_t_item_area_max
                  if data_t_item_area_max0 ~= data_t_item_area_max1 then                
                    current_max_id = k
                  end
                end
              end
              rise_percent2 = 150
              if (data_t[current_max_id]/data_t[i])*100 > rise_percent2 then
                current_max_id = i 
              end
               
              if current_max_id ~= i then  
                for m = 1, current_max_id-i do
                  table.insert(sm_data_t,0)
                end
                table.insert(sm_data_t,1)
               else
                --table.insert(sm_data_t,1)
              end
             else
              table.insert(sm_data_t,0)
            end
          end
        end]]
    --unction ENGINE2_get_stretch_markers(data_t)
      --[[]]
        
        
      -- filt 1
      --[[search max point around couple of windows + add to table
        for i = 1, #data_t, s_area do
          if i+s_area-1 < #data_t then
            -- 2 search max point value in window
            local max_point = 0
            for j =0, s_area-1 do
              data_t_item = data_t[i+j]
              max_point = math.max(max_point, data_t_item)
            end           
            for j =0, s_area-1 do
              data_t_item = data_t[i+j]
              -- check if max point around couple of windows more than thresold
              if data_t_item == max_point and 20*math.log(max_point) > threshold then
                table.insert(sm_data_t,i+j,1)              
               else table.insert(sm_data_t,i+j,0)
              end
            end            
          end
        end   ]]
      -- filt 2    
      --[[area2 search closer sm, delete lower
      for i = 1, #sm_data_t do
        sm_it = sm_data_t[i]
        if sm_it == 1 then
          data_t_it = data_t[i]
          -- search further area
            data_t_area2_max = 0
            for j = i + 1, i + s_area2 do
              if j > #sm_data_t then j = #sm_data_t end
              if sm_data_t[j] == 1 then
                data_t_area2 = data_t[j]
                data_t_area2_max = math.max(data_t_area2_max , data_t_area2 )
              end  
            end 
            if data_t_it < data_t_area2_max  then 
              table.insert(sm_data_t,i,0)
              table.remove(sm_data_t,i+1)
            end
          -- search prev area
            data_t_area2_max = 0
            for j = i-s_area2 , i -1 do
              if j < 1 then j = 1 end
              if sm_data_t[j] == 1 then
                data_t_area2 = data_t[j]
                data_t_area2_max = math.max(data_t_area2_max , data_t_area2 )
              end  
            end 
            if data_t_it < data_t_area2_max  then 
              table.insert(sm_data_t,i,0)
              table.remove(sm_data_t,i+1)
            end        
        end      
      end
      -- threshold filter
      for i = 1, #sm_data_t do
        sm_data_it = sm_data_t[i]
        if sm_data_it == 1 then
          if 20*math.log(data_t[i]) < threshold then
            sm_data_t[i] = 0
          end
        end
      end
  end]]
  
--[[---------------------------------------------------------------------
  f_unction ENGINE2_action_list(gui_params_set)
    if #sel_items_t < 2 then act='#'else act='' end
    if #sel_items_t == 1 then act1=''else act1='#' end
    count_match_actions = 5
    
    count_tempo_actions = 1
    
    actions_table = {'#Action List|',
                  -- 2
                    act..'Match items positions by fitting RMS',
                  -- 3
                    act..'Match items content by fitting RMS',
                  -- 4
                    act..'Match items positions by fitting peaks, detect time selection',
                  -- 5
                    act..'Match items content by fitting peaks, detect time selection|',
                    
                    
                  --11                   
                    act1..'test detect points'}
                    
    ret = gfx.showmenu(table.concat(actions_table, '|'))    
    if ret == 0 then 
      action_name = action_b_name 
      ret_num=gui_params_set
     else 
      action_name = actions_table[ret] 
      if ret <= count_match_actions then ret_num = ret end 
      if ret > count_match_actions and ret <= count_match_actions + count_tempo_actions then
        ret_num = ret + (10 - count_match_actions) end
    end
    return action_name, ret_num
  end
  
-----------------------------------------------------------------------  
  f_unction ENGINE3_find_offsets_by_RMS(set,source)
    
    offset_l = -s_area1 -- windows
    offset_r = s_area1
    if not set then
      if #sel_items_t > 1 then
        ref_RMS_t, _, ref_pos, ref_len = ENGINE1_get_item_data(sel_items_t[1], true, false)
        offsets_t = {0}
        for i = 2, #sel_items_t do
          cur_RMS_t, _, cur_pos = ENGINE1_get_item_data(sel_items_t[i], false, false)
          
          --create diff table
          diff_t = {}
          for offset = offset_l, offset_r, 1 do
            diff_com = 0
            for i = 1, #ref_RMS_t do
              if i+offset < 1 or i+offset > #cur_RMS_t then
               t2_val = 0 else t2_val = cur_RMS_t[i+offset] end
              diff = math.abs(ref_RMS_t[i] - t2_val)
              diff_com = diff + diff_com
            end
            table.insert(diff_t, diff_com)
          end
          
          -- find min diff id
          diff_t_min = math.huge
          for i = 1, #diff_t do
            diff_t_min0 = diff_t_min
            diff_t_it = diff_t[i]
            diff_t_min = math.min(diff_t_it, diff_t_min)
            if diff_t_min0 ~= diff_t_min then diff_t_min_id = i end
          end
          test1 = -(offset_l + diff_t_min_id)*window_time
          --create offset table
          table.insert(offsets_t, -(offset_l + diff_t_min_id)*window_time)
        end
      end
     else -- apply matching
     
      if not source then
        for i = 2, #sel_items_t do
          item = reaper.BR_GetMediaItemByGUID(0, sel_items_t[i][1])
          if item ~= nil then
            reaper.SetMediaItemInfo_Value(item,"D_POSITION",sel_items_t[i][2]+(offsets_t[i]*strenght))
            reaper.UpdateItemInProject(item)
          end
        end
       else
        for i = 2, #sel_items_t do
          item = reaper.BR_GetMediaItemByGUID(0, sel_items_t[i][1])
          if item ~= nil then
            take = reaper.GetActiveTake(item)
            reaper.SetMediaItemTakeInfo_Value(take, 'D_STARTOFFS',sel_items_t[i][4]-(offsets_t[i]*strenght))
            reaper.UpdateItemInProject(item)
          end
        end        
      end
      
    end
  end
  
-----------------------------------------------------------------------  
  f_unction ENGINE3_find_offsets_by_peaks(set,source)
    if timesel_smpls > 0 and timesel_smpls < max_timesel_smpls and exists then  
      offset_smpl_L = -timesel_smpls
      offset_smpl_R = timesel_smpls
      if not set then
        if #sel_items_t > 1 then
          _, _, ref_pos, ref_len, ref_peaks_t = ENGINE1_get_item_data(sel_items_t[1], false, true)
          offsets_t = {0}
          for i = 2, #sel_items_t do
            _, _, cur_pos,_,cur_peaks_t = ENGINE1_get_item_data(sel_items_t[i], false, true)
            
            -- create diff table
            diff_t = {}
            for offset_smpl = offset_smpl_R, offset_smpl_L,-1 do
              diff_com = 0
              for i = 1, #ref_peaks_t do
                if i + offset_smpl < 1 or i + offset_smpl > #ref_peaks_t then
                  t3_val = 0 else t3_val = cur_peaks_t[i + offset_smpl] end
                if t3_val == nil then t3_val = 0 end
                diff = math.abs(ref_peaks_t[i] - t3_val)
                diff_com = diff + diff_com
              end
              table.insert(diff_t, diff_com)
            end
            
            -- find min diff id
              diff_t_min = math.huge
              for i = 1, #diff_t do
                diff_t_min0 = diff_t_min
                diff_t_it = diff_t[i]
                diff_t_min = math.min(diff_t_it, diff_t_min)
                if diff_t_min0 ~= diff_t_min then diff_t_min_id = i-1 end
              end
              
            --create offset table
              table.insert(offsets_t,
                 (offset_smpl_L+diff_t_min_id)/44100)
          end
        end
        
       else -- apply matching
       
        if not source then
          for i = 2, #sel_items_t do
            item = reaper.BR_GetMediaItemByGUID(0, sel_items_t[i][1])
            if item ~= nil then
              reaper.SetMediaItemInfo_Value(item,"D_POSITION",sel_items_t[i][2]+(offsets_t[i]*strenght))
              reaper.UpdateItemInProject(item)
            end
          end
         else
          for i = 2, #sel_items_t do
            item = reaper.BR_GetMediaItemByGUID(0, sel_items_t[i][1])
            if item ~= nil then
              take = reaper.GetActiveTake(item)
              reaper.SetMediaItemTakeInfo_Value(take, 'D_STARTOFFS',sel_items_t[i][4]-(offsets_t[i]*strenght))
              reaper.UpdateItemInProject(item)
            end
          end        
        end
              
      end
    end  end

 
  
  --[[br = [===[---------------------------------------------------------------------------------------------------------------  
 

  
  ---------------------------------------------------------------------------------------------------------------       
  
  ---------------------------------------------------------------------------------------------------------------         

  ---------------------------------------------------------------------------------------------------------------       


    
   
  
  -- calculate tempo average
    -- get tempo for each marker
      tempo_t0 = {}
      for i =1, #sm_t do
        sm_it = sm_t[i]
        if sm_it == 1 then 
          if last_sm_id ~= nil then
            tempo_v = 60/((i - last_sm_id)*window_time)
            table.insert(tempo_t0, tempo_v)
          end              
          last_sm_id = i                
        end
      end
      tempo_t0_sum = 0
      count0 = 1
      last_id0 = 1
      last_id = 1
      for i = 2, #sm_t do
        sm_it = sm_t[i]
        if sm_it == 1 then last_id = i end
        tempo_v = 60/(last_id - last_id0)
        if tempo_v > 0 then 
          tempo_t0_sum = (tempo_t0_sum+tempo_v)
          table.insert(tempo_t0, tempo_v)
          count0 = count0 +1
        end            
        last_id0 = last_id
      end      
      tempo_average0 = tempo_t0_sum / count0      
      average_lim_per = 5
      average_lim =average_lim_per /100 -- %      
    -- filter from 10% average0    
      tempo_average_sum = 0   
      count = 1
      for i = 1, #tempo_t0 do
        tempo_t0_it = tempo_t0[i]
        diff = tempo_average0 / tempo_t0_it
        if diff > (1-average_lim) and diff <(1+average_lim) then
          tempo_average_sum = tempo_average_sum+tempo_t0_it
          count = count +1
        end
      end
      tempo_average_calc = 60/((tempo_average_sum/count)*window_time)
                
     
  --[[ 
   --loop through windows
           for read_pos = 0, item_len, window_time do              
             if read_pos+item_pos > ref_item_pos and read_pos+item_pos < ref_item_pos+ref_item_len then
               
               reaper.GetAudioAccessorSamples(audio_accessor,src_rate,src_num_ch,read_pos,window_samples,audio_accessor_buffer)
               
   -- fft aa buffer                  
                 audio_accessor_buffer.fft(fft_size, true, 1)
                 fft_sum = 0
                 audio_accessor_buffer_fft_t = audio_accessor_buffer.table(1, fft_size)
                 for i = fft_start, fft_end  do
                   value = audio_accessor_buffer_fft_t[i]
                   value_abs = math.abs(value)
                   fft_sum = fft_sum + value_abs
                 end
                 fft_sum = fft_sum / fft_size
                 table.insert(fft_val_t, fft_sum)
                
               audio_accessor_buffer_t = {}
               audio_accessor_buffer.clear()                              
             end -- check if inside ref_item  
           end -- loop every window
           
   -- stream item peaks within timeselection to table 
     -- check for existing in time selection
       exists = true
       if item_pos < timesel_st and item_pos + item_len < timesel_st then exists = false end
       if item_pos + item_len > timesel_end and item_pos > timesel_end then exists = false end
         
     
     
         if timesel_smpls > 0 and timesel_smpls < max_timesel_smpls and get_peaks then 
           if exists then
                    
             pos_delta = item_pos - timesel_st -- if item pos more than time selection start
             if pos_delta > 0 or pos_delta == 0 then -- if item pos = time selection start
               read_pos = 0
              elseif pos_delta < 0 then -- if item pos less time selection start
               read_pos = math.abs(pos_delta)
             end
             
             if item_pos + item_len < timesel_end or item_pos + item_len == timesel_end then
               if pos_delta < 0 then pos_delta = 0 end
               buffer_smpls = math.floor((item_pos + item_len - timesel_st - pos_delta)*44100)
              elseif item_pos + item_len > timesel_end then
               buffer_smpls = math.floor((timesel_end - timesel_st - pos_delta)*44100)
             end
             buffer_smpls = timesel_smpls
         
             audio_accessor_buffer = reaper.new_array(buffer_smpls)
             reaper.GetAudioAccessorSamples(audio_accessor,
               src_rate,src_num_ch,read_pos,buffer_smpls,audio_accessor_buffer)    
             peaks_t = audio_accessor_buffer.table(1, buffer_smpls) 
             
             -- fill empty space           
               if pos_delta > 0 then
                 for i = 1, math.floor(pos_delta*44100) do
                   table.insert(peaks_t, 1, 0)
                 end       
               end
               
               if item_pos + item_len < timesel_end then
                 for i = 1, math.floor((timesel_end - item_pos - item_len)*44100) do
                   table.insert(peaks_t, #peaks_t, 0)
                 end       
               end     
                        
             -- abs table values
             for i = 1, #peaks_t do peaks_t[i]= math.abs(peaks_t[i]) end    
             
           end  
         end
         
         reaper.DestroyAudioAccessor(audio_accessor)  
         
   -- full edges
           if not is_ref1 then 
             -- fill table beginning
             offset1 = (item_pos - ref_item_pos)
             if offset1 > 0 then 
               for i = 1, math.floor(offset1/window_time) do
                 table.insert(fft_val_t, 1, 0)
               end
             end 
             -- fill table end
             offset2 = (item_pos + item_len - ref_item_pos - ref_item_len)
             if offset2 < 0 then 
               for i = 1, math.floor(math.abs(offset2)/window_time) do
                 table.insert(fft_val_t, 0)
               end
             end                           
           end
         
         
         _, trackname = reaper.GetSetMediaTrackInfo_String(track, 'P_NAME','', false)
         if trackname == '' then trackname = '(no name)' end
         ret_name = trackname..'   /   '..reaper.GetTakeName(take)
       end -- if not midi  
     end -- if item ~= nil
     
     
    
     -- smooth fft table  
     for i =2, #fft_val_t do
       if fft_val_t[i]>fft_val_t[i-1] then fft_val_t[i] = fft_val_t[i]*(1-env_t_smooth_ratio) end
       if fft_val_t[i]<fft_val_t[i-1] then fft_val_t[i] = fft_val_t[i]*(1+env_t_smooth_ratio) end
     end  
     
       
        
     return fft_val_t, ret_name, item_pos, item_len, peaks_t
   end -- sel_items_t ~= nil            
  
   
                
 ]===]]
 
 ---------------------------------------------- 
 tips = {}
 tips[1] = {}
 tips[1].title = 'Phrases alignment tips'
 tips[1].text =
 [[
OK so you wanna auto-stretch whole phrases. This mode is useful when you have recorded a lot of back vocals, which have only 2-5 words, not the whole duplicate of couplet or chorus. 
 
 Your simplified what-to-do algorythm is:
 1) Select takes (upper is reference),
 2) Click 'Get & Prepare',
 3) Go drink cofee,
 4) Move slider.
 
 You may ask "WTF <prepare takes> means?". That means:
 1) Clear all stretch markers from selected takes,
 2) Set selected takes takerate to 1.0x,
 3) Check for all takes on reference track is glued,
 4) Crop dub takes positions/lengths to reference take.
 
 OK you get unexpected results, nothing works or works bad.
 Don`t panic, impossible to make it universal for everyone!
 I recommend you to:
 1) Clear silence in takes by any noisegate plugin and do apply FX or glue it (simple putting it on FX chain does NOT affect!),
 2) Organize (glue) your dubs takes on same tracks,
 3) If it still not helps, you can try to change detection settings.
 ]]
 ----------------------------------------------
 tips[2] = {}
 tips[2].title = 'Syllables alignment tips'
 tips[2].text =  [[
OK so you wanna auto-stretch syllables. This mode is useful when you have recorded whole back vocal of couplet or chorus. 
 
 Your simplified what-to-do algorythm is:
 1) Select takes (upper is reference),
 2) Click 'Get & Prepare',
 3) Go drink cofee,
 4) Move slider.
 
 You may ask "WTF <prepare takes> means?". That means:
 1) Clear all stretch markers from selected takes,
 2) Set selected takes takerate to 1.0x,
 3) Check for all takes on reference track is glued,
 4) Crop dub takes positions/lengths to reference take.
 
 OK you get unexpected results, nothing works or works bad.
 Don`t panic, impossible to make it universal for everyone!
 I recommend you to:
 1) Clear silence in takes by any noisegate plugin and do apply FX or glue it (simple putting it on FX chain does NOT affect!),
 2) Organize (glue) your dubs takes on same tracks,
 3) If it still not helps, you can try to change detection settings.
 ]]
